# Master Blueprint: Social Media Platform on Replit

## 1. Project Overview & Architecture (2,500 characters)

This blueprint outlines a full-stack social media platform built on Replit with the following architecture:

**Tech Stack:**
- Frontend: React.js with TypeScript
- Backend: Node.js/Express.js
- Database: PostgreSQL (Replit Database)
- Authentication: JWT with OAuth 2.0 integration
- Real-time: Socket.io for notifications
- Storage: Replit's built-in file storage

**Core Features:**
- User profiles with avatars
- Post creation with text, images, and videos
- Like/comment system
- Follow/unfollow functionality
- Real-time notifications
- Direct messaging
- Hashtag and search functionality
- Admin dashboard

**Architecture Flow:**
1. Client makes request to React frontend
2. Frontend calls Express API endpoints
3. Express handles business logic and database operations
4. PostgreSQL stores all persistent data
5. Socket.io handles real-time updates
6. Replit's native storage handles media files

**Scalability Considerations:**
- Component-based frontend architecture
- RESTful API design
- Database indexing for performance
- Caching layer for frequent queries
- Rate limiting on API endpoints

## 2. Complete File Structure (2,000 characters)

```
social-media-replit/
├── client/
│   ├── public/
│   │   ├── index.html
│   │   └── assets/
│   │       ├── images/
│   │       └── styles/
│   ├── src/
│   │   ├── components/
│   │   │   ├── auth/
│   │   │   │   ├── Login.tsx
│   │   │   │   └── Register.tsx
│   │   │   ├── posts/
│   │   │   │   ├── PostCard.tsx
│   │   │   │   ├── PostForm.tsx
│   │   │   │   └── Comments.tsx
│   │   │   ├── profile/
│   │   │   │   ├── ProfileHeader.tsx
│   │   │   │   └── EditProfile.tsx
│   │   │   ├── common/
│   │   │   │   ├── Navbar.tsx
│   │   │   │   ├── Footer.tsx
│   │   │   │   └── NotificationBell.tsx
│   │   │   └── messaging/
│   │   │       ├── MessageList.tsx
│   │   │       └── MessageForm.tsx
│   │   ├── pages/
│   │   │   ├── Home.tsx
│   │   │   ├── Profile.tsx
│   │   │   ├── Explore.tsx
│   │   │   ├── Notifications.tsx
│   │   │   └── Messages.tsx
│   │   ├── store/
│   │   │   ├── authSlice.ts
│   │   │   ├── postSlice.ts
│   │   │   └── store.ts
│   │   ├── utils/
│   │   │   ├── api.ts
│   │   │   └── helpers.ts
│   │   ├── App.tsx
│   │   ├── index.tsx
│   │   └── types.ts
│   └── package.json
├── server/
│   ├── controllers/
│   │   ├── authController.ts
│   │   ├── postController.ts
│   │   ├── userController.ts
│   │   └── messageController.ts
│   ├── middleware/
│   │   ├── auth.ts
│   │   └── errorHandler.ts
│   ├── models/
│   │   ├── User.ts
│   │   ├── Post.ts
│   │   ├── Comment.ts
│   │   └── Message.ts
│   ├── routes/
│   │   ├── authRoutes.ts
│   │   ├── postRoutes.ts
│   │   ├── userRoutes.ts
│   │   └── messageRoutes.ts
│   ├── services/
│   │   ├── authService.ts
│   │   ├── postService.ts
│   │   └── notificationService.ts
│   ├── utils/
│   │   ├── config.ts
│   │   ├── database.ts
│   │   └── socket.ts
│   ├── app.ts
│   └── package.json
├── .replit
└── README.md
```

## 3. Detailed Implementation Steps (10,000 characters)

### Backend Setup (Node.js/Express)

1. Initialize server:
```bash
cd server
npm init -y
npm install express cors mongoose jsonwebtoken bcryptjs multer socket.io dotenv helmet morgan
npm install --save-dev typescript ts-node @types/express @types/cors @types/node nodemon
```

2. Configure TypeScript (server/tsconfig.json):
```json
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

3. Set up Express app (server/app.ts):
```typescript
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import authRoutes from './routes/authRoutes';
import postRoutes from './routes/postRoutes';
import { errorHandler } from './middleware/errorHandler';
import { initializeSocket } from './utils/socket';

const app = express();

// Middleware
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/posts', postRoutes);

// Error handling
app.use(errorHandler);

// Database connection
import './utils/database';

const PORT = process.env.PORT || 5000;
const server = app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Initialize Socket.io
initializeSocket(server);
```

### Database Models

1. User model (server/models/User.ts):
```typescript
import mongoose, { Document } from 'mongoose';
import bcrypt from 'bcryptjs';

export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  avatar: string;
  bio: string;
  followers: mongoose.Types.ObjectId[];
  following: mongoose.Types.ObjectId[];
  matchPassword: (password: string) => Promise<boolean>;
}

const userSchema = new mongoose.Schema<IUser>(
  {
    username: { type: String, required: true, unique: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    avatar: { type: String, default: '' },
    bio: { type: String, default: '' },
    followers: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    following: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
  },
  { timestamps: true }
);

userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

userSchema.methods.matchPassword = async function (enteredPassword: string) {
  return await bcrypt.compare(enteredPassword, this.password);
};

export default mongoose.model<IUser>('User', userSchema);
```

2. Post model (server/models/Post.ts):
```typescript
import mongoose, { Document } from 'mongoose';

export interface IPost extends Document {
  user: mongoose.Types.ObjectId;
  content: string;
  image?: string;
  likes: mongoose.Types.ObjectId[];
  comments: mongoose.Types.ObjectId[];
  hashtags: string[];
}

const postSchema = new mongoose.Schema<IPost>(
  {
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    content: { type: String, required: true },
    image: { type: String },
    likes: [{ type: mongoose.Schema.Types.ObjectId, ref: 'User' }],
    comments: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Comment' }],
    hashtags: [{ type: String }],
  },
  { timestamps: true }
);

export default mongoose.model<IPost>('Post', postSchema);
```

### Authentication Implementation

1. Auth controller (server/controllers/authController.ts):
```typescript
import { Request, Response } from 'express';
import User from '../models/User';
import jwt from 'jsonwebtoken';
import { ReplitDB } from '../utils/database';

const generateToken = (id: string) => {
  return jwt.sign({ id }, process.env.JWT_SECRET!, {
    expiresIn: '30d',
  });
};

export const registerUser = async (req: Request, res: Response) => {
  try {
    const { username, email, password } = req.body;
    
    const userExists = await User.findOne({ $or: [{ email }, { username }] });
    if (userExists) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const user = await User.create({ username, email, password });
    
    const token = generateToken(user._id);
    
    res.status(201).json({
      _id: user._id,
      username: user.username,
      email: user.email,
      token,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

export const loginUser = async (req: Request, res: Response) => {
  try {
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const isMatch = await user.matchPassword(password);
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    const token = generateToken(user._id);
    
    res.json({
      _id: user._id,
      username: user.username,
      email: user.email,
      token,
    });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};
```

## 4. Database Schema & Configuration (2,500 characters)

**Database Schema Details:**

1. **Users Collection:**
- `username`: String (unique, required)
- `email`: String (unique, required)
- `password`: String (hashed, required)
- `avatar`: String (URL to image)
- `bio`: String
- `followers`: Array of User references
- `following`: Array of User references
- `createdAt`: Timestamp
- `updatedAt`: Timestamp

2. **Posts Collection:**
- `user`: Reference to User (required)
- `content`: String (required)
- `image`: String (optional URL)
- `likes`: Array of User references
- `comments`: Array of Comment references
- `hashtags`: Array of Strings
- `createdAt`: Timestamp
- `updatedAt`: Timestamp

3. **Comments Collection:**
- `user`: Reference to User (required)
- `post`: Reference to Post (required)
- `content`: String (required)
- `createdAt`: Timestamp
- `updatedAt`: Timestamp

4. **Messages Collection:**
- `sender`: Reference to User (required)
- `receiver`: Reference to User (required)
- `content`: String (required)
- `read`: Boolean (default: false)
- `createdAt`: Timestamp

**Database Configuration (server/utils/database.ts):**

```typescript
import mongoose from 'mongoose';
import { ReplitDB } from '@replit/database';

// Configure Replit DB for key-value storage
const replitDB = new ReplitDB();

// MongoDB connection for relational data
const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI!);
    console.log(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`Error: ${error}`);
    process.exit(1);
  }
};

export { connectDB, replitDB };
```

**Environment Configuration (server/utils/config.ts):**

```typescript
import dotenv from 'dotenv';

dotenv.config();

const config = {
  PORT: process.env.PORT || 5000,
  MONGO_URI: process.env.MONGO_URI || 'mongodb://localhost:27017/socialmedia',
  JWT_SECRET: process.env.JWT_SECRET || 'secret123',
  CLIENT_URL: process.env.CLIENT_URL || 'http://localhost:3000',
  NODE_ENV: process.env.NODE_ENV || 'development',
};

export default config;
```

## 5. Authentication & Security Implementation (2,500 characters)

**JWT Authentication Middleware (server/middleware/auth.ts):**

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import User from '../models/User';
import config from '../utils/config';

export interface AuthenticatedRequest extends Request {
  user?: any;
}

export const protect = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  let token;
  
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith('Bearer')
  ) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, config.JWT_SECRET) as { id: string };
      
      req.user = await User.findById(decoded.id).select('-password');
      next();
    } catch (error) {
      res.status(401).json({ message: 'Not authorized, token failed' });
    }
  }
  
  if (!token) {
    res.status(401).json({ message: 'Not authorized, no token' });
  }
};

export const admin = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  if (req.user && req.user.isAdmin) {
    next();
  } else {
    res.status(401).json({ message: 'Not authorized as admin' });
  }
};
```

**Security Measures:**

1. **Helmet Middleware:**
```typescript
app.use(helmet());
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'", "cdn.example.com"],
    styleSrc: ["'self'", "'unsafe-inline'", "fonts.googleapis.com"],
    imgSrc: ["'self'", "data:", "cdn.example.com"],
    connectSrc: ["'self'", "api.example.com"],
  },
}));
```

2. **Rate Limiting:**
```typescript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

app.use('/api/', limiter);
```

3. **Data Sanitization:**
```typescript
import mongoSanitize from 'express-mongo-sanitize';
import xss from 'xss-clean';

app.use(mongoSanitize());
app.use(xss());
```

4. **CORS Configuration:**
```typescript
app.use(cors({
  origin: config.CLIENT_URL,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
```

5. **Password Hashing:**
```typescript
// Already implemented in User model pre-save hook
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});
```

## 6. API Endpoints & Business Logic (3,000 characters)

**Post Controller (server/controllers/postController.ts):**

```typescript
import { Request, Response } from 'express';
import Post from '../models/Post';
import User from '../models/User';
import { AuthenticatedRequest } from '../middleware/auth';

export const createPost = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { content, image } = req.body;
    const user = req.user._id;
    
    // Extract hashtags
    const hashtags = content.match(/#\w+/g) || [];
    
    const post = await Post.create({
      user,
      content,
      image,
      hashtags: hashtags.map(tag => tag.slice(1))
    });
    
    res.status(201).json(post);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

export const getPosts = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const posts = await Post.find()
      .populate('user', 'username avatar')
      .sort({ createdAt: -1 });
      
    res.json(posts);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

export const likePost = async (req: AuthenticatedRequest, res: Response) => {
  try {
    const post = await Post.findById(req.params.id);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Check if already liked
    if (post.likes.includes(req.user._id)) {
      post.likes = post.likes.filter(
        id => id.toString() !== req.user._id.toString()
      );
    } else {
      post.likes.push(req.user._id);
    }
    
    await post.save();
    
    res.json(post);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};
```

**User Routes (server/routes/userRoutes.ts):**

```typescript
import express from 'express';
import { protect } from '../middleware/auth';
import {
  getUserProfile,
  updateUserProfile,
  followUser,
  getFollowers,
  getFollowing
} from '../controllers/userController';

const router = express.Router();

router.route('/profile')
  .get(protect, getUserProfile)
  .put(protect, updateUserProfile);

router.route('/follow/:id')
  .put(protect, followUser);

router.route('/followers')
  .get(protect, getFollowers);

router.route('/following')
  .get(protect, getFollowing);

export default router;
```

**Post Routes (server/routes/postRoutes.ts):**

```typescript
import express from 'express';
import { protect } from '../middleware/auth';
import {
  createPost,
  getPosts,
  getPostById,
  deletePost,
  likePost,
  addComment
} from '../controllers/postController';

const router = express.Router();

router.route('/')
  .get(getPosts)
  .post(protect, createPost);

router.route('/:id')
  .get(getPostById)
  .delete(protect, deletePost);

router.route('/:id/like')
  .put(protect, likePost);

router.route('/:id/comment')
  .post(protect, addComment);

export default router;
```

## 7. Frontend Components & User Interface (2,500 characters)

**React Setup (client/package.json):**

```json
{
  "name": "client",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@reduxjs/toolkit": "^1.8.0",
    "axios": "^0.27.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.3.0",
    "react-scripts": "5.0.1",
    "socket.io-client": "^4.5.1",
    "typescript": "^4.7.4",
    "redux-persist": "^6.0.0",
    "react-icons": "^4.4.0",
    "styled-components": "^5.3.5"
  }
}
```

**Post Card Component (client/src/components/posts/PostCard.tsx):**

```typescript
import React from 'react';
import styled from 'styled-components';
import { AiOutlineHeart, AiFillHeart, AiOutlineComment } from 'react-icons/ai';
import { PostType } from '../../types';

interface PostCardProps {
  post: PostType;
  onLike: (postId: string) => void;
  onComment: (postId: string) => void;
}

const PostCard: React.FC<PostCardProps> = ({ post, onLike, onComment }) => {
  const isLiked = post.likes.includes('current-user-id'); // Replace with actual user ID from store
  
  return (
    <CardContainer>
      <UserInfo>
        <Avatar src={post.user.avatar} alt={post.user.username} />
        <Username>{post.user.username}</Username>
      </UserInfo>
      
      <Content>{post.content}</Content>
      
      {post.image && <PostImage src={post.image} alt="Post" />}
      
      <Actions>
        <ActionButton onClick={() => onLike(post._id)}>
          {isLiked ? <AiFillHeart color="red" /> : <AiOutlineHeart />}
          <span>{post.likes.length}</span>
        </ActionButton>
        
        <ActionButton onClick={() => onComment(post._id)}>
          <AiOutlineComment />
          <span>{post.comments.length}</span>
        </ActionButton>
      </Actions>
    </CardContainer>
  );
};

// Styled components
const CardContainer = styled.div`
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  background: white;
`;

const UserInfo = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: 12px;
`;

const Avatar = styled.img`
  width: 40px;
  height: 40px;
  border-radius: 50%;
  margin-right: 12px;
`;

const Username = styled.span`
  font-weight: bold;
`;

const Content = styled.p`
  margin-bottom: 12px;
`;

const PostImage = styled.img`
  width: 100%;
  max-height: 500px;
  object-fit: contain;
  margin-bottom: 12px;
  border-radius: 4px;
`;

const Actions = styled.div`
  display: flex;
  gap: 16px;
`;

const ActionButton = styled.button`
  display: flex;
  align-items: center;
  gap: 4px;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
`;

export default PostCard;
```

## 8. Deployment & Production Setup (1,500 characters)

**Replit Configuration (.replit):**

```ini
language = "nodejs"
run = "cd server && npm install && npm run dev"
```

**Production Deployment Steps:**

1. **Configure Environment Variables:**
- In Replit, go to the Secrets tab
- Add the following environment variables:
  - `MONGO_URI`: Your MongoDB connection string
  - `JWT_SECRET`: A strong secret for JWT
  - `CLIENT_URL`: Your frontend URL

2. **Database Setup:**
- For production, use MongoDB Atlas or another cloud database service
- Configure IP whitelisting and database users with proper permissions

3. **Build Frontend:**
```bash
cd client
npm run build
```

4. **Serve Frontend from Backend:**
```typescript
// Add to server/app.ts
import path from 'path';

if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../../client/build')));
  
  app.get('*', (req, res) => {
    res.sendFile(path.resolve(__dirname, '../../client/build', 'index.html'));
  });
}
```

5. **Enable Always-On in Replit:**
- Upgrade to Replit Hacker plan for Always-On feature
- Configure the Always-On setting for your repl

6. **Monitoring:**
- Set up health check endpoint
- Configure logging to monitor errors
- Consider integrating with monitoring services

**Production Optimization:**
- Enable compression middleware
- Implement caching headers
- Set up proper CORS for production domains
- Configure HTTPS (automatically handled by Replit)

**Backup Strategy:**
- Regular database backups
- Version control all code
- Store secrets securely

This comprehensive blueprint provides everything needed to build a full-featured social media platform on Replit with modern technologies and best practices. The implementation includes complete code samples, security measures, and deployment instructions for a production-ready application.